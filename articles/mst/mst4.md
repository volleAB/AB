# 输入URL到展示的过程（js解析）

## 前言

> 难顶，因为自己的懒惰，没有尽快的更新文章，让自己的目标半个月之内打破。今天是入职的前一天，天气不好，待在酒店里，又继续完成我的目标吧ヾ(◍°∇°◍)ﾉﾞ

## 词法分析

这一阶段的词法分析就是检查你在编写中是否有一些比较低级的错误，比如一些api的拼写错误，

## 预编译

我们都知道在解析js文件时，函数声明与变量声明都需要提升到作用域的顶部的，这些操作就是我们的`预编译`也叫做`预处理`、`预解析`，大概有以下几个处理：

1. 预编译的顺序是`从上到下`，函数的优先级高于变量，函数声明提前到当前作用域最顶端，在var之上（let与const不会出现声明提升）。

2. 函数执行的时候，函数内部才会进行预编译，如果有参数，先给实参赋值再进行函数内部的预编译。

3. 预编译函数是声明+定义（开辟了内存空间，形参值默认是undefined）。

4. 预编译变量是只声明，不赋值，默认为undefined。

5. 函数重名时，后者会覆盖前者。

6. 变量重名时，不会重新声明，但是执行代码的时候会重新赋值。

7. 变量和函数重名的时候，函数的优先级高于变量。

### 声明提前

这是一个比较基础的知识点，函数除了匿名函数之外都可提升到作用域的顶层。有一个比较特殊：

```js
// 函数声明

function doIt () {
    // do some work
}

// 变量声明
let a = fuction () {
    // do some work
}
```

第二种函数的写法，他的声明不会提升到作用域的顶层的，这个相当于变量的赋值。

当函数与变量重名，且没对变量进行赋值时，函数声明优先级会高一些，可能是因为变量还没赋值时，value是underfined。

```js
console.log(a);
    
function a () {
    return ('you do it!');
}

var a = '123';
```

let/const 使用不当时会带来暂时性死区的问题。

```js
console.log(a);

let a = 'Hello world';
```

如果使用的是var就不会报错，但打出来的是undefined，因为它只是把变量声明提升到了作用域的顶层，还没有进行赋值。

如果使用let/const 就会报错。

> 预编译可不止这些哈

### 分号处理

在现在的js文件的编写中，在一句话的结尾是不是应该加上分号还是一个有争议的问题。不过JS解释器有一个Semicolon Insertion规则，它会按照一定规则，在适当的位置补充分号，譬如列举几条自动加分号的规则

* 当有换行符（包括含有换行符的多行注释），并且下一个token没法跟前面的语法匹配时，会自动补分号。
* 当有}时，如果缺少分号，会补分号。
* 程序源代码结束时，如果缺少分号，会补分号。

不加是为了让代码减少视觉干扰，加是为避免出现不必要的错误。

> 这段代码会出现错误

```js
(function(a){
    console.log(a)
})()
(function(a){
    console.log(a)
})()
```

> 正确

```js
;(function(a){
    console.log(a)
})();
;(function(a){
    console.log(a)
})();
```

### 函数执行时的预解析

函数的组成分为：函数名，函数执行语句体，参数三部分组成。

1. 实参：可以粗略的理解成当在调用函数时候需要向函数执行体中传入的指令。
2. 形参：可以理解成函数在定义时，需要接受到相关的指令来执行函数体语句的实参指令的占位符。

```js
var n = 1;
fn(n);
function fn() {
    console.log(n);
    var n = 2;
}

var n = 1;
fn(n);
function fn(n) {
    console.log(n);
    var n = 2;
}
```

此时打印出来的是undefined，是因为函数fn没有声明对应的形参。

第二种就是声明了形参，被实参fn(n)的n赋值，所以打印出来的就是1。

```js
function foo(a = 1, b, c) {
    console.log(a, b, c);
}

foo(undefined, 12, 22);
```

这种的话还是会使用foo的默认值，a = 1。

发现undefined不能覆盖参数默认值，null和NaN都能去覆盖参数默认值，可以得出函数参数的优先级：undefined < 默认参 < 除undefined以外的实参 (NaN / null)。

## js执行

解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：
* 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）
* VO（变量对象）和AO（活动对象）
* 作用域链
* this机制等

这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性

**执行上下文**

* 浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶（不可被弹出）
* 然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部
* 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。
* 这样依次执行（最终都会回到全局执行上下文）

譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收

然后执行上下文与VO，作用域链，this的关系是：
每一个执行上下文，都有三个重要属性：

* 变量对象(Variable object，VO)
* 作用域链(Scope chain)
* this

**VO与AO**

VO是执行上下文的属性（抽象概念），但是只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）
AO（activation object)，当函数被调用者激活，AO就被创建了
可以理解为：
* 在函数上下文中：VO === AO
* 全局上下文中：VO === this === global

总的来说，VO中会存放一些变量信息（如声明的变量，函数，arguments参数等等）

作用域链：
它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。

譬如流程简述：
在函数上下文中，查找一个变量foo
如果函数的VO中找到了，就直接使用
否则去它的父级作用域链中（__parent__）找
如果父级中没找到，继续往上找
直到全局上下文中也没找到就报错

**this指针**

这也是js的核心知识之一，由于内容过多，这里就不展开，仅提及部分，之后会放在learn的分类中细说。
注意：this是执行上下文环境的一个属性，而不是某个变量对象的属性

因此:
* this是没有一个类似搜寻变量的过程
* 当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻
* this的值只取决中进入上下文时的情况

经典的例子：

```js
var baz = 200;
var bar = {
    baz: 100,
    foo: function() {
        console.log(this.baz);
    }};
var foo = bar.foo;
// 进入环境：global
foo(); 
// 200，严格模式中会报错，Cannot read property 'baz' of undefined
// 进入环境：global bar
bar.foo(); // 100
```

### 其他行为

## 分享

![share](../../images/mst/mst4-1.jpg)

Valentin B. Kremer  2018-12-27