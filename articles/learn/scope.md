## 作用域

作用域执行上下文（执行环境）的分类

* 全局执行环境：是JS代码开始运行时的默认环境（浏览器中为window对象）。全局执行环境的变量对象始终都是作用域链中的最后一个对象
* 函数执行环境：当某个函数被调用时，会先创建一个执行环境及相应的作用域链。然后使用arguments和其他命名参数的值来初始化执行环境的变量对象
* 使用eval()执行代码

eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。注：不涉及ES6中的块级作用域执行上下文的组成

* Variable Object（VO变量对象） : 变量（variables)，函数声明（function declaration)，函数形参（arguments）
* [[Scope属性]] ：指向作用域链，主要用于变量查找
* this指针：指向一个环境对象，是调用当前可执行代码的对象的引用

产生执行上下文的两个阶段    创建阶段（当函数被调用，但是开始执行函数内部代码之前）

* 创建变量对象VO
* 设置[[Scope]]属性的值
* 设置this的值

激活/代码执行阶段

* 初始化变量对象，即设置变量的值、函数的引用，然后解释/执行代码

创建变量对象（VO）过程1.根据函数的参数，创建并初始化arguments object2.扫描函数内部代码，查找函数声明（function declaration）

* 对于所有找到的函数声明，将函数名和函数引用存入VO中
* 如果VO中已经有同名函数，那么就进行覆盖

扫描函数内部代码，查找变量声明（Variable declaration）

* 对于所有找到的变量声明(通过var声明)，将变量名存入VO中，并初始化为undefined
* 如果变量名跟已经声明的形参或函数相同，则什么也不做

注：步骤2和3成为变量提升，函数声明提升优于变量声明提升作用域 VS 执行上下文    

作用域的组成

1. 作用域内变量信息和代码结构信息的记录（Environment Record)
2. 一个指向当前作用域的父作用域的引用

两者的关系

* 存储关系，执行上下文中的[[Scope]]属性存储了当前作用域
* 执行上下文在运行时确定，是动态的，随时会变；作用域是在定义时确定，永远不会变

**作用域链**    

当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。

**词法作用域**    

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变 。

```js
var x = "globol value";
var getValue = function(){    
    alert(x);    //弹出"undefined"    
    var x = "local value";    
    alert(x);    //弹出"local value";
}
getValue();
```

因为在getValue这个函数中有var x = "local value";变量声明会提升，但是赋值语句不会，因为在作用域内有了声明，就不会去上个作用域去找，但是x没有赋值，所以弹出来的就是undefined。

```js
function A(){    
    var a=1;    
    var d=2;    
    B(d);
}

function B(d){    
    console.log(a);
}  
```  

js的作用域是词法作用域无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。    

如果把B定义在A里面，B就可以读到a了。

```js
var a = {    
    name : "volle",    
    age : 20,    
    sex : "male",
    }
console.log(a.name);
console.log(a.sex);
with(a) {    
    console.log(name);    
    console.log(sex);
}
```
with 语句用于设置代码在特定对象中的作用域闭包    

> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外。

* 变量的作用域无非就是两种：全局变量和局部变量
* JS语言的特殊之处，函数内部可以直接读取全局变量，但函数外部无法获取函数内的局部变量
* 闭包的出现：需要得到函数内的局部变量
* 闭包的概念：能够读取到其他函数内部变量的函数。本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。

**闭包的用途**

* 可以读取函数内部的变量（实现一个暴露内部变量，而且外部可以访问修改的函数）
* 让这些变量的值始终保持在内存中 ——>涉及到垃圾回收机制
* 闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联

1. 滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2. 会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

说起闭包，最明显的特点有三个

1. 函数套函数。
2. 内部函数可以访问外部函数的变量。
3. 局部变量，垃圾回收机制无法收回。Closures (闭包)是使用被作用域封闭的变量，函数，闭包等执行的一个函数的作用域。通常我们用和其相应的函数来指代这些作用域。(可以访问独立数据的函数)

## 分享

![share](../../images/learn/share2.jpg)

Krisjanis Mezulis  2019-05-12